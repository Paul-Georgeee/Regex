# A simple Regex(Regular Expression) parser

一个简单的正则表达式解析器，仅支持最简单的正则表达式语法，即`|`、`*`操作符，以及使用括号控制优先级。

可以按照如下的方式使用

```c++
#include<RE.h>

int main()
{
    Regex re("(0|1|2|3|4|5|6|7|8|9)*@qq.com");
    cout << re.match("2333333@qqq.com") << endl;
}
```

按照编译原理/自动机课上所教，将正则表达式转化为NFA，再用子集构造法将NFA转化为DFA，最后将DFA最小化。具体转化方法可以参照龙书上面所讲。由正则表达式生成NFA的过程并未采取先生成语法树再转化，而是暴力的先找`|`，如果没有的话则只需要从左到右生成即可，但是生成语法树的做法便于后续添加语法糖以及对应的语法检查。

`main.cpp`里面是对代码的一些简单的测试，由于使用最原始的正则表达式语法，一些常用的正则表达式的编写有些麻烦，仅进行了这些简单的测试。

DFA最小化采用的是先求得哪些状态之间可区分，哪些不可区分，随后将不可区分的状态合并成新的状态。不可区分的定义是对于状态p、q和任意串w，$\delta(p, w)$ 在终结状态当且仅当$\delta(q,w)$在终结状态

求解可区分状态采取如下归纳做法：

- Basic：空串区分终结状态和其他非终结状态。
- Induction：对于p、q，若存在输入符号c，$\delta(p, c) = r,\delta(q,c) = s$，且r和s可区分，则p和q可区分

在代码实现上，对于每一对`(r,s)`，用一个`depend`链表来保存上述的`(p,q)`。这样子当`(r,s)`被标记为可区分时，标记对应链表中的每一对为可区分。这样子总体可以在$O(n^2)$的时间内完成

